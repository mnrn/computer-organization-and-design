    ########################################
    # @brief バブルソートのテストプログラム
    # @date  作成日     : 2015/12/16
    # @date  最終更新日 : 2015/12/16
    #
    # C言語におけるソートアルゴリズム
    #     void sort(int v[], int n)
    #     {
    #         int i, j;
    #         for (i = 0; i < n; i += 1) {
    #             for (j = i - 1; j >= 0 && v[i] > v[j + 1]; j -= 1) {
    #                 swap(v, j);
    #             }
    #         }
    #     }
    # をMipsアセンブリ言語によって記述する
    ########################################



    # Data Segment
    .data
items:
    .word 5, 3, 4, 1, 2



    # Text Segment
    .text



    #************************************************************
    # main関数
    #************************************************************
    .globl main
main:
    la    $a0, items    # レジスタ$a0にitemsのアドレスを転送
    li    $a1, 5        # レジスタ$a1に定数5を転送

    addi  $sp, $sp, -4  # スタックに1word分のスペースをプッシュする
    sw    $ra, 0($sp)   # スタックに戻りアドレス$raを退避する

    jal   sort          # sort(items, 5)を呼び出す

    lw    $ra, 0($sp)   # スタックに退避した戻りアドレス$raを復元
    addi  $sp, $sp, 4   # スタックに1word分のスペースをポップする

    lw    $a0, 0($a0)   # システムコールの引数にitems[0]を渡す
    li    $v0, 1        # 整数を印字するために$v0に1を代入する

    syscall             # items[0]の印字

    jr    $ra           # プログラムの終了



    #************************************************************
    # バブルソート
    #************************************************************
sort:
    ########################################
    # レジスタの退避
    ########################################
    
    addi  $sp, $sp, -20  # スタックにレジスタ5つ分のスペースをプッシュ
    sw    $ra, 16($sp)   # スタックに$raを退避
    sw    $s3, 12($sp)   # スタックに$s3を退避
    sw    $s2, 8($sp)    # スタックに$s2を退避
    sw    $s1, 4($sp)    # スタックに$s1を退避
    sw    $s0, 0($sp)    # スタックに$s0を退避


    ########################################
    # 手続き本体
    ########################################

    # パラメタのコピー
    move  $s2, $a0       # $a0を$s2にコピー($a0の退避)
    move  $s3, $a1       # $a1を$s3にコピー($a1の退避)


    # 外側のループ
    move  $s0, $zero         # i = 0
for1tst:
    slt   $t0, $s0, $s3      # $s0 >= $s3 (i >= n)ならば、$t0 = 0
    beq   $t0, $zero, exit1  # $s0 >= $s3 (i >= n)ならば、exit1へ

    # 内側のループ
    addi  $s1, $s0, -1       # j = i - 1
for2tst:
    slti  $t0, $s1, 0        # $s1 < 0 (j < 0) ならば、$t0 = 1
    bne   $t0, $zero, exit2  # $s1 < 0 (j < 0) ならば、exit2へ
    sll   $t1, $s1, 2        # $t1 = j * 4
    add   $t2, $s2, $t1      # $t2 = v + (j * 4)
    lw    $t3, 0($t2)        # $t3 = v[j]
    lw    $t4, 4($t2)        # $t4 = v[j + 1]
    slt   $t0, $t4, $t3      # $t4 >= $t3 (v[j + 1] >= v[j])ならば、$t0 = 0
    beq   $t0, $zero, exit2  # $t4 >= $t3 (v[j + 1] >= v[j])ならば、exit2へ

    # パラメタの引き渡しと呼び出し
    move  $a0, $s2           # swap用の第1引数にvを渡す
    move  $a1, $s1           # swap用の第2引数にjを渡す
    jal   swap               # swap(v, j)を呼び出す

    # 内側のループ
    addi  $s1, $s1, -1       # j -= 1
    j     for2tst            # 内側のループの条件判定に戻る

    # 外側のループ
exit2:
    addi  $s0, $s0, 1        # i += 1
    j     for1tst            # 外側のループの条件判定に戻る

    ########################################
    # レジスタの復元
    ########################################

exit1:  
    lw    $s0, 0($sp)    # スタックから$s0を復元
    lw    $s1, 4($sp)    # スタックから$s1を復元
    lw    $s2, 8($sp)    # スタックから$s2を復元
    lw    $s3, 12($sp)   # スタックから$s3を復元
    lw    $ra, 16($sp)   # スタックから$raを復元
    addi  $sp, $sp, 20   # スタックにレジスタ5つ分のスペースをポップ


    ########################################
    # 呼び出し元への戻り
    ########################################
    
    jr    $ra            # 呼び出し元のルーチンへ戻る



    #************************************************************
    # @brief C言語における
    #     void swap(int v[], int k)
    #     {
    #         int temp;
    #         temp   = v[k];
    #         v[k]   = v[k+1];
    #         v[k+1] = temp;
    #     }
    # をMipsアセンブリ言語によって記述する
    #************************************************************
    .globl swap
swap:
    sll   $t1, $a1, 2     # (k * 4)をレジスタ$t1に代入
    add   $t1, $a0, $t1   # v + (k * 4)をレジスタ$t1に代入

    # NOTE: ここまでの操作でレジスタ$t1はv[k]のアドレスを表す

    lw    $t0, 0($t1)     # レジスタ$t0(temp)にv[k]を転送
    lw    $t2, 4($t1)     # レジスタ$t2にv[k+1]を転送

    sw    $t2, 0($t1)     # v[k]   = レジスタ$t2
    sw    $t0, 4($t1)     # v[k+1] = レジスタ$t0(temp)

    jr    $ra             # 呼び出し元に戻る
    
